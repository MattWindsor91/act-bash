#!/usr/bin/env python3

"""Automatically generates an act.conf for the local machine and puts it on stdout."""

#  The Automagic Compiler Tormentor
#  Copyright (c) 2018--2020 Matt Windsor and contributors.
#  - ACT itself is licensed under the MIT License. See the LICENSE file in the
#    project root for more information.
#  - ACT is based in part on code from the Herdtools7 project
#    (https://github.com/herd/herdtools7) : see the LICENSE.herd file in the
#    project root for more information.

import argparse
import collections
import itertools
import multiprocessing
import pathlib
import platform
import subprocess
import sys
import typing
from datetime import datetime

from act_py import act_id, config

gcc_like_compilers = ["gcc", "clang"]
olevels = [0, 3]

gcc_targets_of_arch = {
    "x86_64": [config.Target.X86_ATT, config.Target.X64_ATT],
    "i386": [config.Target.X86_ATT],
}

herdtools_backends = {"herd": ["herd", "herd7"], "litmus": ["litmus", "litmus7"]}

nodetrans = str.maketrans("-", "_")


def trim_node(full_node: str) -> str:
    (node_prefix, _, _) = full_node.partition(".")
    return node_prefix.translate(nodetrans)


def gcc_args(arch: str, target: config.Target, olevel: int) -> typing.Iterator[str]:
    if target.force_32bit(arch):
        yield "-m32"
    if olevel != 0:
        yield f"-O{olevel}"
    yield "-DNO_PTHREADS"


def command_works(cmd: str, *args: str) -> bool:
    """Runs the given command with the given argument list, and returns whether
    it succeeded.
    """
    try:
        test: subprocess.CompletedProcess = subprocess.run(
            [cmd, *args], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
        return test.returncode == 0
    except FileNotFoundError:
        # Assume this is a missing program
        return False


def gcc_like_compiler_stanza(
    cmd: str, arch: str, target: config.Target, olevel: int
) -> config.Compiler:
    """Emits a compiler stanza for a particular O-level of a GCC-like compiler.
    Assumes that the compiler has already been checked.
    """
    args = list(gcc_args(arch, target, olevel))
    return config.Compiler(style="gcc", target=target, cmd=cmd, args=args)


def gcc_like_compiler_stanzas(
    cmd: str, arch: str
) -> typing.Iterator[typing.Tuple[str, config.Compiler]]:
    """Emits a set of compiler stanzas for a particular GCC-like compiler.
    Assumes that the compiler has already been checked.
    """
    targets = gcc_targets_of_arch[arch]
    for (target, olevel) in itertools.product(targets, olevels):
        compiler_id = ".".join([cmd, target.short_name, f"O{olevel}"])
        compiler = gcc_like_compiler_stanza(cmd, arch, target, olevel)
        yield compiler_id, compiler


def lookup_gcc_like_compiler(
    cmd: str, arch: str
) -> typing.Mapping[str, config.Compiler]:
    """Tests to see if the named GCC-like compiler exists.
    If so, emits a dictionary containing one or more stanzas for it.
    If not, emits an empty dictionary.
    """
    return (
        dict(gcc_like_compiler_stanzas(cmd, arch))
        if command_works(cmd, "--version")
        else {}
    )


def lookup_gcc_like_compilers(arch: str) -> typing.Mapping[str, config.Compiler]:
    return collections.ChainMap(
        *(lookup_gcc_like_compiler(cmd, arch) for cmd in gcc_like_compilers)
    )


def lookup_local_compilers(arch: str) -> typing.Mapping[str, config.Compiler]:
    # Space for future expansion
    return lookup_gcc_like_compilers(arch)


def herdtools_backend_stanzas(
    cmd: str, style: str, c_model: typing.Optional[str]
) -> typing.Iterator[typing.Tuple[str, config.Backend]]:
    yield (
        cmd,
        config.Backend(
            cmd=cmd, style=style, c_model=c_model if style == "herd" else None
        ),
    )


def lookup_herdtools_backend(
    cmd: str, style: str, c_model: typing.Optional[str]
) -> typing.Mapping[str, config.Backend]:
    """Tests to see if the named Herdtools-style backend exists.
    If so, emits a dictionary containing one or more stanzas for it.
    If not, emits an empty dictionary.
    """
    return (
        dict(herdtools_backend_stanzas(cmd, style, c_model))
        if command_works(cmd, "-version")
        else {}
    )


def lookup_herdtools_backends(
    c_model: typing.Optional[str]
) -> typing.Mapping[str, config.Backend]:
    return collections.ChainMap(
        *(
            lookup_herdtools_backend(cmd, style, c_model)
            for (style, cmds) in herdtools_backends.items()
            for cmd in cmds
        )
    )


def lookup_local_backends(
    c_model: typing.Optional[str]
) -> typing.Mapping[str, config.Backend]:
    # Space for future expansion
    return lookup_herdtools_backends(c_model)


def lookup_local_machine(c_model: typing.Optional[str]) -> config.Machine:
    """Looks up compilers and backends on this machine.

    :param c_model: The C model override for herd-style backends, if any.

    :return: A `Machine` with the identifier "localhost", and any found
    compilers and backends on the local machine.
    """
    arch = platform.machine()

    compilers: typing.Mapping[str, config.Compiler] = lookup_local_compilers(arch)
    backends: typing.Mapping[str, config.Backend] = lookup_local_backends(c_model)

    return config.Machine("localhost", arch, compilers, backends)


def make_fuzz() -> config.Fuzz:
    """Makes a fuzzer configuration that respects the limits of the current
    machine.

    :return: A fuzz configuration.
    """
    cores: int
    try:
        cores = multiprocessing.cpu_count()
    except NotImplementedError:
        print(
            "Couldn't get number of cores, putting in a sensible default.",
            file=sys.stderr,
        )
        cores = 2
    return config.Fuzz(params={act_id.Id("cap.threads"): cores}, flags=dict())


def print_default(mach: config.Machine) -> None:
    print("default {")
    print(f"    try machine {mach.id}")
    print("}")


def print_header(mach: config.Machine) -> None:
    print(f"# Auto-generated act.conf for '{mach.id}' (architecture {mach.arch}).")
    print(f"# Generated on {datetime.today()}.")


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-c",
        "--c-model",
        metavar="FILE",
        type=lambda x: pathlib.Path(x),
        help="If supplied, the path to the C model to supply to 'herd'-like backends",
    )
    args = parser.parse_args()

    mach: config.Machine = lookup_local_machine(args.c_model)
    fuzz: config.Fuzz = make_fuzz()

    print_header(mach)
    mach.print()
    print()
    fuzz.print()
    print_default(mach)


if __name__ == "__main__":
    main()
