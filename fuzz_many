#!/usr/bin/env bash
# Runs the ACT fuzzer several times on each of a set of C litmus tests,
# outputting the results into a directory.
#
# For usage information, scroll down to the `usage` function.

set -o errexit
set -o pipefail
set -o nounset

SCRIPTDIR="${SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"}"
readonly SCRIPTDIR

# shellcheck source=scripts/act_bash/exec.sh
source "${SCRIPTDIR}/act_bash/exec.sh"
# shellcheck source=scripts/act_bash/log.sh
source "${SCRIPTDIR}/act_bash/log.sh"
# shellcheck source=scripts/act_bash/naming.sh
source "${SCRIPTDIR}/act_bash/naming.sh"


## Constants ##


# The name to give to the symlink created in 'fire and forget' mode.
readonly SYMLINK_NAME="_fuzz_latest"

# The suffix to add to trace files when tracing is on.
readonly TRACE_SUFFIX=".trace"

## Arguments ##


# The number of times to run the fuzzer for each input.
COUNT=10

# The name to give to the fuzzing output directory.
DIR_NAME="fuzz_$(date '+%y_%m_%d_%H_%M_%S')"

# Whether or not we're running ACT programs through `dune exec`.
DUNE_EXEC="false"

# If set to 'true', do some human-convenience steps.
FIRE_AND_FORGET="false"

# If set to 'true', dump fuzzer traces adjacent to the fuzzer output.
TRACES="false"

# Whether or not verbose logging is enabled.
VERBOSE="false"


# If we look like we're on a Mac, open directory $1 in Finder.
#
# $1: fuzzer directory
open_directory() {
  local dir_name="${1}"

  if [[ "$(uname)" = "Darwin" ]]; then
    open "${dir_name}"
  fi
}


# Runs the fuzzer a given amount of times on a litmus test, outputting the
# results to a directory with systematic naming.
#
# Globals:
#   ACT_FUZZ: read
#
# Arguments:
#   1: fuzzer output directory
#   2: name of file to mutate
#   3: count
fuzz_file() {
  local dir_name="${1}"
  local in_file="${2}"
  local count="${3}"

  act::log "Fuzzing %s..." "${in_file}"

  for k in $(seq "${count}"); do
    act::log " %d" "${k}"
    fuzz_file_once "${dir_name}" "${in_file}" "${k}"
  done

  act::log " done.\n"
}


# Performs one round of fuzzing on a file.
#
# Arguments:
#   1: the path of the output directory.
#   2: the file to mutate.
#   3: the number of this fuzzing pass.
fuzz_file_once() {
  local dir_name="${1}"
  local in_file="${2}"
  local k="${3}"

  local out_name
  out_name="$(act::fuzz_name "${in_file}" "${k}")"
  local out_file
  out_file="${dir_name}/${out_name}.litmus"

  # We create a temp file instead of piping directly into `modify-header` so
  # that we can investigate any syntax errors in the fuzzer's output;
  # otherwise, the invalid input would be swallowed by `modify-header` and lost.
  local tmp_file="${out_file}.pre_header"

  if [[ "${TRACES}" = "true" ]]; then
    local trace_file
    trace_file="${dir_name}/${out_name}${TRACE_SUFFIX}"
    act::fuzz run "${in_file}" -trace-output "${trace_file}" > "${tmp_file}"
  else
    act::fuzz run "${in_file}" > "${tmp_file}"
  fi

  act::c modify-header -name "${out_name}" -o "${out_file}" "${tmp_file}"
  rm "${tmp_file}"
}


# Performs various helper actions; enabled by the 'fire and forget' switch.
#
# Globals:
#   SYMLINK_NAME: read
#   DIR_NAME: read
run_helpers() {
  act::log "Linking %s to %s.\n" "${SYMLINK_NAME}" "${DIR_NAME}"

  rm -f "${SYMLINK_NAME}"
  ln -s "${DIR_NAME}" "${SYMLINK_NAME}"

  act::log "Opening %s.\n" "${DIR_NAME}"
  open_directory "${DIR_NAME}"
}


# Prints usage information.
usage() {
  echo "Usage: $0 [-c COUNT] [-d DIR_NAME] [-tqvxh?] INFILES..."
  echo
  echo "-c: number of times to run the fuzzer per file"
  echo "-d: override autogenerated directory name"
  echo "-f: 'fire and forget': set up 'latest' symlink and open in Finder"
  echo "-t: dump fuzzer traces as well"
  echo "-v/-q: verbose/quiet"
  echo "-x: run ACT binaries with \`dune exec\`"
  echo "-h/-?: usage"
  exit
}


# The main function.
#
# Globals:
#   COUNT: read, write, set-readonly
#   DIR_NAME: read, write, set-readonly
#   DUNE_EXEC: read, write, set-readonly
#   FIRE_AND_FORGET: read, write, set-readonly
#   VERBOSE: read, write, set-readonly
main() {
  while getopts "c:d:ftqvx?h" a; do
    case ${a} in
    d) DIR_NAME=${OPTARG} ;;
    c) COUNT=${OPTARG} ;;
    f) FIRE_AND_FORGET="true" ;;
    t) TRACES="true" ;;
    q) VERBOSE="false" ;;
    v) VERBOSE="true" ;;
    x) DUNE_EXEC="true" ;;
    h|?) usage ;;
    esac
  done
  readonly VERBOSE DUNE_EXEC
  shift $((OPTIND-1))

  if [[ $# -lt 1 ]]; then act::arg_error "need at least one file argument"; fi
  if [[ ${COUNT} -le 0 ]]; then act::arg_error "count must be a non-negative integer"; fi

  if [[ "${TRACES}" = "true" ]]; then act::log "Outputting traces on this run.\n"; fi

  mkdir -p "${DIR_NAME}"
  act::log "Fuzzing to %s.\n" "${DIR_NAME}"

  for file in "${@}"; do
    fuzz_file "${DIR_NAME}" "${file}" "${COUNT}"
  done

  if [[ "${FIRE_AND_FORGET}" = "true" ]]; then run_helpers; fi
}

## Entry point. ##
main "${@}"
