#!/usr/bin/env bash
#
# A driver that works by:
#
# 1) converting a Litmus test to a delitmusified C file and matching header;
# 2) generating a new Litmus test that calls into the C file;
# 3) building a Litmus harness over the stub test;
# 4) patching up the harness so that it can compile against the C file;
# 5) compiling the whole thing against the compiler under test.

set -euo pipefail

SCRIPTDIR="${SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"}"
readonly SCRIPTDIR

# shellcheck source=scripts/act_bash/args.sh
source "${SCRIPTDIR}/act_bash/args.sh"
# shellcheck source=scripts/act_bash/exec.sh
source "${SCRIPTDIR}/act_bash/exec.sh"
# shellcheck source=scripts/act_bash/log.sh
source "${SCRIPTDIR}/act_bash/log.sh"
# shellcheck source=scripts/act_bash/naming.sh
source "${SCRIPTDIR}/act_bash/naming.sh"

## Constants and arguments ##


# The backend ID to use to get state sets.
# Must not be empty at the end of argument parsing.
BACKEND=""

# The name of the compiler to compile through.
# Must not be empty at the end of argument parsing.
COMPILER=""

# Whether or not we're running ACT programs through `dune exec`.
DUNE_EXEC="false"

# The path to the C Litmus test being used as a subject.
INPUT_FILE=""

# The directory to which we will output intermediate results.
# If empty, we construct a temporary directory.
OUTPUT_DIR=""

# The name to give to the Litmus test.
# If empty, we extract one from the input file.
TEST_NAME=""

# Whether or not verbose logging is enabled.
VERBOSE="false"


## Functions ##


# Runs the delitmusifier on an input litmus test, saving an
# aux file and header file for future consumption.
#
# Globals:
#   - ACT_C (read)
#   - SCRIPTDIR (read)
#
# Arguments:
#   1: the compiler ID.
#   2: path to the C litmus test to delitmusify and compile.
#   3: path to which a delitmus auxiliary file should be written.
#   4: path to which the intermediate C file should be written.
#   5: path to which a header file exposing the C file's functions should be written.
delitmus() {
  local compiler="$1"
  local infile="$2"
  local auxfile="$3"
  local cfile="$4"
  local hfile="$5"

  act::delitmus \
    -style vars-as-parameters \
    -impl-suffix "_body" \
    -no-qualify-locals \
    -aux "${auxfile}" -o "${cfile}" "${infile}"
  "${SCRIPTDIR}"/make_header.awk "${cfile}" > "${hfile}"
}


# Produces a Litmus stub harness from a delitmus aux file.
#
# Globals:
#   - LITMUS (read)
#   - SCRIPTDIR (read)
#   - Various globals read by the scripts in `act_bash/exec.sh`
#
# Arguments:
#   1: the backend ID.
#   2: the compiler ID.
#   3: path to the delitmus aux file to use when generating the harness.
#   4: path to which a skeleton Litmus test should be written.
#   5: directory into which the Litmus harness should be constructed.
make_litmus_harness() {
  local backend="$1"
  local compiler="$2"
  local auxfile="$3"
  local stubfile="$4"
  local litdir="$5"

  local carch
  carch=$(act::compiler info "${compiler}" emits)

  act::c make-stub "${auxfile}" -output "${stubfile=}"
  # TODO(@MattWindsor91): store the outputted commands somewhere and run them
  act::backend make-harness -backend "${backend}" -carch "${carch}" "${stubfile}" -output "${litdir}" > /dev/null
}


# Runs the driver once all arguments are parsed.
#
# Globals:
#   - OUTPUT_DIR (read)
#   - TEST_NAME (read)
run() {
  local auxfile="${OUTPUT_DIR}/${TEST_NAME}.aux.json"
  local stubfile="${OUTPUT_DIR}/${TEST_NAME}.litmus"

  local litdir="${OUTPUT_DIR}/exec"
  mkdir -p "${litdir}"

  local cfile="${litdir}/${TEST_NAME}.body.c"
  local runfile="${litdir}/${TEST_NAME}.c"
  local hname="${TEST_NAME}.body.h"
  local hfile="${litdir}/${hname}"

  delitmus "${COMPILER}" "${INPUT_FILE}" "${auxfile}" "${cfile}" "${hfile}"
  make_litmus_harness "${BACKEND}" "${COMPILER}" "${auxfile}" "${stubfile}" "${litdir}"
  "${SCRIPTDIR}/add_header_to_litmus" "${hname}" "${runfile}"
  act::run_with_bcqvx "${SCRIPTDIR}/harness/compile_and_run" "${litdir}"
}


# Prints the script's usage and exits.
usage() {
  echo "usage: $0 -b BACKEND_ID -c COMPILER_ID [-d DIR] [-n NAME] [-${ACT_STANDARD_FLAGS}] FILE" >&2
  echo
  echo "-b: ID of Litmus-style ACT backend to use for making harnesses"
  echo "-c: ID of compiler to use to compile file"
  echo "-d: directory to use for outputting intermediate files"
  echo "-n: name to use for Litmus test"
  act::standard_usage

  exit 1
}


# Main function.
main() {
  while getopts "b:c:d:n:${ACT_STANDARD_OPTS}" a; do
    case ${a} in
    b) BACKEND=${OPTARG} ;;
    c) COMPILER=${OPTARG} ;;
    d) OUTPUT_DIR=${OPTARG} ;;
    n) TEST_NAME=${OPTARG} ;;
    *) act::parse_standard_args "${a}" "${OPTARG:-}" ;;
    esac
  done
  # VERBOSE etc. are used indirectly by various library functions.
  # shellcheck disable=SC2034
  readonly BACKEND COMPILER VERBOSE DUNE_EXEC
  shift $((OPTIND-1))

  if [[ -z ${BACKEND} ]]; then act::arg_error "expected a nonempty backend (-b)"; fi
  if [[ -z ${COMPILER} ]]; then act::arg_error "expected a nonempty compiler (-c)"; fi
  if [[ $# -ne 1 ]]; then act::arg_error "expected precisely one anonymous argument"; fi

  INPUT_FILE="$1"
  if [[ -z ${TEST_NAME} ]]; then
    TEST_NAME="$("${SCRIPTDIR}/litmus_test_name" "${INPUT_FILE}")"
    act::log "auto-naming test: '%s'.\n" "${TEST_NAME}"
  fi
  readonly INPUT_FILE TEST_NAME

  if [[ -z ${OUTPUT_DIR} ]]; then act::setup_temp_output_dir; fi
  readonly OUTPUT_DIR

  act::check_dune_exec

  run
}

## Entry point ##
main "$@"
